{
    "Programs": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">extend interface Program {\n    sourceType: \"script\" | \"module\";\n    body: [ Statement | ModuleDeclaration ];\n}\n</code></pre>",
            "<p>Parsers must specify `sourceType` as `\"module\"` if the source has been parsed as an ES6 module. Otherwise, `sourceType` must be `\"script\"`.</p>"
        ],
        "/es5.md": [
            "<pre><code class=\"language-js\">interface Program <: Node {\n    type: \"Program\";\n    body: [ Directive | Statement ];\n}\n</code></pre>",
            "<p>A complete program source tree.</p>"
        ]
    },
    "Functions": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">extend interface Function {\n    generator: boolean;\n}\n</code></pre>"
        ],
        "/es5.md": [
            "<pre><code class=\"language-js\">interface Function <: Node {\n    id: Identifier | null;\n    params: [ Pattern ];\n    body: FunctionBody;\n}\n</code></pre>",
            "<p>A function [declaration](#functiondeclaration) or [expression](#functionexpression).</p>"
        ],
        "/extensions/type-annotations.md": [
            "<pre><code class=\"language-js\">extend interface Function {\n    returnType: TypeAnnotation | null;\n}\n</code></pre>",
            "<p>The `returnType` property is used to specify the type annotation for the return value of the function.</p>"
        ]
    },
    "Expressions": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">interface Super <: Node {\n    type: \"Super\";\n}\n\nextend interface CallExpression {\n    callee: Expression | Super;\n    arguments: [ Expression | SpreadElement ];\n}\n\nextend interface MemberExpression {\n    object: Expression | Super;\n}\n</code></pre>",
            "<p>A `super` pseudo-expression.</p>",
            "<pre><code class=\"language-js\">interface SpreadElement <: Node {\n    type: \"SpreadElement\";\n    argument: Expression;\n}\n\nextend interface ArrayExpression {\n    elements: [ Expression | SpreadElement | null ];\n}\n\nextend interface NewExpression {\n    arguments: [ Expression | SpreadElement ];\n}\n</code></pre>",
            "<p>Spread expression, e.g., `[head, ...iter, tail]`, `f(head, ...iter, ...tail)`.</p>",
            "<p>**FIXME:** This describes the Esprima and Acorn behaviors, which is not currently aligned with the SpiderMonkey behavior.</p>",
            "<pre><code class=\"language-js\">extend interface AssignmentExpression {\n    left: Pattern;\n}\n</code></pre>",
            "<p>Note that pre-ES6 code was allowed [to pass references around](https://github.com/estree/estree/pull/20#issuecomment-74584758) and so `left` was much more liberal; an implementation might choose to continue using [old definition](https://github.com/estree/estree/blob/master/es5.md#assignmentexpression) if it needs to support such legacy code.</p>",
            "<pre><code class=\"language-js\">extend interface Property {\n    key: Expression;\n    method: boolean;\n    shorthand: boolean;\n    computed: boolean;\n}\n</code></pre>"
        ],
        "/es2018.md": [
            "<pre><code class=\"language-js\">extend interface ObjectExpression {\n    properties: [ Property | SpreadElement ];\n}\n</code></pre>",
            "<p>Spread properties, e.g., `{a: 1, ...obj, b: 2}`.</p>"
        ],
        "/es5.md": [
            "<pre><code class=\"language-js\">interface Expression <: Node { }\n</code></pre>",
            "<p>Any expression node. Since the left-hand side of an assignment may be any expression in general, an expression can also be a pattern.</p>"
        ]
    },
    "Expressions/ArrowFunctionExpression": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">interface ArrowFunctionExpression <: Function, Expression {\n    type: \"ArrowFunctionExpression\";\n    body: FunctionBody | Expression;\n    expression: boolean;\n    generator: false;\n}\n</code></pre>",
            "<p>A fat arrow function expression, e.g., `let foo = (bar) => { /* body */ }`.</p>"
        ]
    },
    "Expressions/YieldExpression": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">interface YieldExpression <: Expression {\n    type: \"YieldExpression\";\n    argument: Expression | null;\n    delegate: boolean;\n}\n</code></pre>",
            "<p>A `yield` expression.</p>"
        ]
    },
    "Classes": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">interface Class <: Node {\n    id: Identifier | null;\n    superClass: Expression | null;\n    body: ClassBody;\n}\n</code></pre>"
        ],
        "/es2022.md": [
            "<p>These language extensions cover following class features proposals:</p>",
            "<p>[Class Fields]</p>",
            "<p>[Static Class Features]</p>",
            "<p>[Private Methods]</p>",
            "<p>[Static Initialization Blocks].</p>"
        ]
    },
    "Classes/ClassBody": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">interface ClassBody <: Node {\n    type: \"ClassBody\";\n    body: [ MethodDefinition ];\n}\n</code></pre>"
        ],
        "/es2022.md": [
            "<pre><code class=\"language-js\">extend interface ClassBody {\n    body: [ MethodDefinition | PropertyDefinition | StaticBlock ];\n}\n</code></pre>"
        ]
    },
    "Classes/MethodDefinition": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">interface MethodDefinition <: Node {\n    type: \"MethodDefinition\";\n    key: Expression;\n    value: FunctionExpression;\n    kind: \"constructor\" | \"method\" | \"get\" | \"set\";\n    computed: boolean;\n    static: boolean;\n}\n</code></pre>"
        ],
        "/es2022.md": [
            "<pre><code class=\"language-js\">extend interface MethodDefinition {\n    key: Expression | PrivateIdentifier;\n}\n</code></pre>",
            "<p>When `key` is a `PrivateIdentifier`, `computed` must be `false` and `kind` can not be `\"constructor\"`.</p>"
        ]
    },
    "Classes/ClassDeclaration": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">interface ClassDeclaration <: Class, Declaration {\n    type: \"ClassDeclaration\";\n    id: Identifier;\n}\n</code></pre>"
        ]
    },
    "Classes/ClassExpression": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">interface ClassExpression <: Class, Expression {\n    type: \"ClassExpression\";\n}\n</code></pre>"
        ]
    },
    "Classes/MetaProperty": {
        "/es2015.md": [
            "<pre><code class=\"language-js\">interface MetaProperty <: Expression {\n    type: \"MetaProperty\";\n    meta: Identifier;\n    property: Identifier;\n}\n</code></pre>",
            "<p>`MetaProperty` node represents `new.target` meta property in ES2015. In the future, it will represent other meta properties as well.</p>"
        ]
    },
    "BinaryOperator": {
        "/es2016.md": [
            "<pre><code class=\"language-js\">extend enum BinaryOperator {\n    \"**\"\n}\n</code></pre>"
        ]
    },
    "AssignmentOperator": {
        "/es2016.md": [
            "<pre><code class=\"language-js\">extend enum AssignmentOperator {\n    \"**=\"\n}\n</code></pre>"
        ]
    },
    "Function": {
        "/es2017.md": [
            "<pre><code class=\"language-js\">extend interface Function {\n    async: boolean;\n}\n</code></pre>"
        ]
    },
    "AwaitExpression": {
        "/es2017.md": [
            "<pre><code class=\"language-js\">interface AwaitExpression <: Expression {\n    type: \"AwaitExpression\";\n    argument: Expression;\n}\n</code></pre>"
        ]
    },
    "Statements": {
        "/es2018.md": [
            "<pre><code class=\"language-js\">extend interface ForOfStatement {\n  await: boolean;\n}\n</code></pre>",
            "<p>`for-await-of` statements, e.g., `for await (const x of xs) {`</p>"
        ],
        "/es5.md": [
            "<pre><code class=\"language-js\">interface Statement <: Node { }\n</code></pre>",
            "<p>Any statement.</p>"
        ]
    },
    "Template Literals": {
        "/es2018.md": [
            "<pre><code class=\"language-js\">extend interface TemplateElement {\n    value: {\n        cooked: string | null;\n        raw: string;\n    };\n}\n</code></pre>",
            "<p>If the template literal is tagged and the text has an invalid escape, `cooked` will be `null`, e.g., ``tag`\\unicode and \\u{55}` ``</p>"
        ]
    },
    "Patterns": {
        "/es2018.md": [
            "<pre><code class=\"language-js\">extend interface ObjectPattern {\n    properties: [ AssignmentProperty | RestElement ];\n}\n</code></pre>",
            "<p>Rest properties, e.g., `{a, ...rest} = obj`.</p>"
        ],
        "/es5.md": [
            "<p>Destructuring binding and assignment are not part of ES5, but all binding positions accept `Pattern` to allow for destructuring in ES6. Nevertheless, for ES5, the only `Pattern` subtype is [`Identifier`](#identifier).</p>",
            "<pre><code class=\"language-js\">interface Pattern <: Node { }\n</code></pre>"
        ]
    },
    "Literal": {
        "/es2020.md": [
            "<pre><code class=\"language-js\">extend interface Literal <: Expression {\n    type: \"Literal\";\n    value: string | boolean | null | number | RegExp | bigint;\n}\n</code></pre>",
            "<p>`value` property can be a `BigInt` value to represent `BigInt` literals\nsuch as `100n`.</p>"
        ],
        "/es5.md": [
            "<pre><code class=\"language-js\">interface Literal <: Expression {\n    type: \"Literal\";\n    value: string | boolean | null | number | RegExp;\n}\n</code></pre>",
            "<p>A literal token. Note that a literal can be an expression.</p>"
        ]
    },
    "Literal/BigIntLiteral": {
        "/es2020.md": [
            "<pre><code class=\"language-js\">interface BigIntLiteral <: Literal {\n  bigint: string;\n}\n</code></pre>",
            "<p>`bigint` property is the string representation of the `BigInt` value.\nIt doesn't include the suffix `n`.</p>",
            "<p>In environments that don't support `BigInt` values, `value` property will be\n`null` as the `BigInt` value can't be represented natively.</p>"
        ]
    },
    "Classes/PropertyDefinition": {
        "/es2022.md": [
            "<pre><code class=\"language-js\">interface PropertyDefinition <: Node {\n    type: \"PropertyDefinition\";\n    key: Expression | PrivateIdentifier;\n    value: Expression | null;\n    computed: boolean;\n    static: boolean;\n}\n</code></pre>",
            "<p>When `key` is a `PrivateIdentifier`, `computed` must be `false`.</p>"
        ]
    },
    "Classes/MethodDefinition/PrivateIdentifier": {
        "/es2022.md": [
            "<pre><code class=\"language-js\">interface PrivateIdentifier <: Node {\n    type: \"PrivateIdentifier\";\n    name: string;\n}\n</code></pre>",
            "<p>A private identifier refers to private class elements. For a private name `#a`, its `name` is `a`.</p>",
            "<pre><code class=\"language-js\">extend interface MemberExpression {\n    property: Expression | PrivateIdentifier;\n}\n</code></pre>",
            "<p>When `property` is a `PrivateIdentifier`, `computed` must be `false`.</p>",
            "<p>When `object` is a `Super`, `property` can not be a `PrivateIdentifier`.</p>"
        ]
    },
    "Classes/StaticBlock": {
        "/es2022.md": [
            "<pre><code class=\"language-js\">interface StaticBlock <: BlockStatement {\n    type: \"StaticBlock\";\n}\n</code></pre>",
            "<p>A static block `static { }` is a block statement serving as an additional static initializer.</p>"
        ]
    },
    "Modules": {
        "/es2022.md": [
            "<p>See [Arbitrary module namespace identifier names] for more details.</p>"
        ]
    },
    "Node objects": {
        "/es5.md": [
            "<p>ESTree AST nodes are represented as `Node` objects, which may have any prototype inheritance but which implement the following interface:</p>",
            "<pre><code class=\"language-js\">interface Node {\n    type: string;\n    loc: SourceLocation | null;\n}\n</code></pre>",
            "<p>The `type` field is a string representing the AST variant type. Each subtype of `Node` is documented below with the specific string of its `type` field. You can use this field to determine which interface a node implements.</p>",
            "<p>The `loc` field represents the source location information of the node. If the node contains no information about the source location, the field is `null`; otherwise it is an object consisting of a start position (the position of the first character of the parsed source region) and an end position (the position of the first character after the parsed source region):</p>",
            "<pre><code class=\"language-js\">interface SourceLocation {\n    source: string | null;\n    start: Position;\n    end: Position;\n}\n</code></pre>",
            "<p>Each `Position` object consists of a `line` number (1-indexed) and a `column` number (0-indexed):</p>",
            "<pre><code class=\"language-js\">interface Position {\n    line: number; // >= 1\n    column: number; // >= 0\n}\n</code></pre>"
        ]
    },
    "Identifier": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface Identifier <: Expression, Pattern {\n    type: \"Identifier\";\n    name: string;\n}\n</code></pre>",
            "<p>An identifier. Note that an identifier may be an expression or a destructuring pattern.</p>"
        ],
        "/extensions/type-annotations.md": [
            "<pre><code class=\"language-js\">extend interface Identifier {\n    typeAnnotation: TypeAnnotation | null;\n}\n</code></pre>",
            "<p>The `typeAnnotation` property is used only in the case of variable declarations with type annotations or function arguments with type annotations.</p>"
        ]
    },
    "Literal/RegExpLiteral": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface RegExpLiteral <: Literal {\n  regex: {\n    pattern: string;\n    flags: string;\n  };\n}\n</code></pre>",
            "<p>The `regex` property allows regexes to be represented in environments that don’t\nsupport certain flags such as `y` or `u`. In environments that don't support\nthese flags `value` will be `null` as the regex can't be represented natively.</p>"
        ]
    },
    "Statements/ExpressionStatement": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface ExpressionStatement <: Statement {\n    type: \"ExpressionStatement\";\n    expression: Expression;\n}\n</code></pre>",
            "<p>An expression statement, i.e., a statement consisting of a single expression.</p>"
        ]
    },
    "Statements/Directive": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface Directive <: ExpressionStatement {\n    expression: Literal;\n    directive: string;\n}\n</code></pre>",
            "<p>A directive from the directive prologue of a script or function.\nThe `directive` property is the raw string source of the directive without quotes.</p>"
        ]
    },
    "Statements/BlockStatement": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface BlockStatement <: Statement {\n    type: \"BlockStatement\";\n    body: [ Statement ];\n}\n</code></pre>",
            "<p>A block statement, i.e., a sequence of statements surrounded by braces.</p>"
        ]
    },
    "Statements/FunctionBody": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface FunctionBody <: BlockStatement {\n    body: [ Directive | Statement ];\n}\n</code></pre>",
            "<p>The body of a function, which is a block statement that may begin with directives.</p>"
        ]
    },
    "Statements/EmptyStatement": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface EmptyStatement <: Statement {\n    type: \"EmptyStatement\";\n}\n</code></pre>",
            "<p>An empty statement, i.e., a solitary semicolon.</p>"
        ]
    },
    "Statements/DebuggerStatement": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface DebuggerStatement <: Statement {\n    type: \"DebuggerStatement\";\n}\n</code></pre>",
            "<p>A `debugger` statement.</p>"
        ]
    },
    "Statements/WithStatement": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface WithStatement <: Statement {\n    type: \"WithStatement\";\n    object: Expression;\n    body: Statement;\n}\n</code></pre>",
            "<p>A `with` statement.</p>"
        ]
    },
    "Declarations": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface Declaration <: Statement { }\n</code></pre>",
            "<p>Any declaration node. Note that declarations are considered statements; this is because declarations can appear in any statement context.</p>"
        ]
    },
    "Declarations/FunctionDeclaration": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface FunctionDeclaration <: Function, Declaration {\n    type: \"FunctionDeclaration\";\n    id: Identifier;\n}\n</code></pre>",
            "<p>A function declaration. Note that unlike in the parent interface `Function`, the `id` cannot be `null`.</p>"
        ]
    },
    "Declarations/VariableDeclaration": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface VariableDeclaration <: Declaration {\n    type: \"VariableDeclaration\";\n    declarations: [ VariableDeclarator ];\n    kind: \"var\";\n}\n</code></pre>",
            "<p>A variable declaration.</p>"
        ]
    },
    "Declarations/VariableDeclaration/VariableDeclarator": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface VariableDeclarator <: Node {\n    type: \"VariableDeclarator\";\n    id: Pattern;\n    init: Expression | null;\n}\n</code></pre>",
            "<p>A variable declarator.</p>"
        ]
    },
    "Expressions/ThisExpression": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface ThisExpression <: Expression {\n    type: \"ThisExpression\";\n}\n</code></pre>",
            "<p>A `this` expression.</p>"
        ]
    },
    "Expressions/ArrayExpression": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface ArrayExpression <: Expression {\n    type: \"ArrayExpression\";\n    elements: [ Expression | null ];\n}\n</code></pre>",
            "<p>An array expression. An element might be `null` if it represents a hole in a sparse array. E.g. `[1,,2]`.</p>"
        ]
    },
    "Expressions/ObjectExpression": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface ObjectExpression <: Expression {\n    type: \"ObjectExpression\";\n    properties: [ Property ];\n}\n</code></pre>",
            "<p>An object expression.</p>"
        ]
    },
    "Expressions/ObjectExpression/Property": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface Property <: Node {\n    type: \"Property\";\n    key: Literal | Identifier;\n    value: Expression;\n    kind: \"init\" | \"get\" | \"set\";\n}\n</code></pre>",
            "<p>A literal property in an object expression can have either a string or number as its `value`. Ordinary property initializers have a `kind` value `\"init\"`; getters and setters have the kind values `\"get\"` and `\"set\"`, respectively.</p>"
        ]
    },
    "Expressions/FunctionExpression": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface FunctionExpression <: Function, Expression {\n    type: \"FunctionExpression\";\n}\n</code></pre>",
            "<p>A `function` expression.</p>"
        ]
    },
    "Expressions/ConditionalExpression": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface ConditionalExpression <: Expression {\n    type: \"ConditionalExpression\";\n    test: Expression;\n    alternate: Expression;\n    consequent: Expression;\n}\n</code></pre>",
            "<p>A conditional expression, i.e., a ternary `?`/`:` expression.</p>"
        ]
    },
    "Expressions/CallExpression": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface CallExpression <: Expression {\n    type: \"CallExpression\";\n    callee: Expression;\n    arguments: [ Expression ];\n}\n</code></pre>",
            "<p>A function or method call expression.</p>"
        ]
    },
    "Expressions/NewExpression": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface NewExpression <: Expression {\n    type: \"NewExpression\";\n    callee: Expression;\n    arguments: [ Expression ];\n}\n</code></pre>",
            "<p>A `new` expression.</p>"
        ]
    },
    "Expressions/SequenceExpression": {
        "/es5.md": [
            "<pre><code class=\"language-js\">interface SequenceExpression <: Expression {\n    type: \"SequenceExpression\";\n    expressions: [ Expression ];\n}\n</code></pre>",
            "<p>A sequence expression, i.e., a comma-separated sequence of expressions.</p>"
        ]
    },
    "Type Annotations": {
        "/extensions/type-annotations.md": [
            "<pre><code class=\"language-js\">interface TypeAnnotation <: Node { }\n</code></pre>",
            "<p>Any type annotation.</p>"
        ]
    }
}